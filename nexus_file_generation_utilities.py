#Depends on Biopython
from Bio import SeqIO
import subprocess
import glob
import multiprocessing
from multiprocessing import Pool,Lock
import os

def create_matrix_string(taxa_list):
    """
    Creates the part of the Nexus file that actually contains the data.
    INPUT: A list of taxa as generated by the SeqIO module of Biopython.
    """
    s = ""
    for sequence in taxa_list:
        s += ("\t{}\t{}\n".format(sequence.id,sequence.seq))
    return s


def create_method_string(method):
    """
    Creates the part of the Nexus file that handles the selection of the method.
    Currently only neighbor joining ("nj") and maximum parsimony ("mp") are supported.
    """
    if method == "nj":
        method_string = "set criterion = distance;\nnj brlens = yes;"
    elif method == "mp":
        method_string = "set criterion = parsimony;\nhsearch addseq=random nreps=1000;"
    else:
        raise ValueError("The PAUP* method is not known. Only MP and NJ are supported")
    return method_string

def create_nexus_file(taxa_list,out_filename,method):
    """
    Creates the content of the Nexus file. 
    The input is a list of taxons as generated by the SeqIO.parse method of Biopython.SeqIO.
    Out_filename is the name under which PAUP* saves the tree once it processes the Nexus file.
    Method is the method that PAUP* is supposed to use (Currently only neighbor joining ("nj") and maximum parsimony ("mp") are supported.)
    """
    for i in range(len(taxa_list)):
        if len(taxa_list[i]) != len(taxa_list[i-1]):
            raise ValueError("the sequences do not have equal length!")
    
    template ="""#NEXUS
Begin data;
  dimensions ntax={num_taxa} nchar={seq_len};
  format datatype=protein missing=? gap=-;
  matrix
{matrix}
    ;
end;

Begin Paup;
{method_string}
savetrees /file={filename} format=newick brlens=yes
;

end;
""".format(num_taxa = len(taxa_list),seq_len=len(taxa_list[0]),matrix = create_matrix_string(taxa_list),filename=os.getcwd()+"/"+out_filename,method_string = create_method_string(method))

    return template



def nexus_from_fasta(fasta_path,method = "nj"):
    """
    Method to parse a .fasta file and create a suitable Nexus file for PAUP*.
    Method is the method that PAUP* is supposed to use (Currently only neighbor joining ("nj") and maximum parsimony ("mp") are supported.)
    """
    taxa = []
    if(method == "nj"):
        out_path = fasta_path.replace(".fasta",".nj.treefile")
    elif(method == "mp"):
        out_path = fasta_path.replace(".fasta",".mp.treefile")
    else:
        raise ValueError("Method not supported")
    for seq_record in SeqIO.parse(fasta_path, "fasta"):
        taxa.append(seq_record)
    
    nexus_template = create_nexus_file(taxa,out_path,method)
    return nexus_template,out_path




def paup_tree_processfile(args):
    nexus_file,globallock = args
    parameters = ["paup4a166_ubuntu64",nexus_file,"--noninteractive"]
    rv = subprocess.run(parameters,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    globallock.acquire()
    if rv == 1:
        pass
        #print("File '{}' processed.".format(name))
    else:
        pass
        #print("Error when processing file '{}'\n,error code{}".format(nexus_file,rv))
        #print("Stderr:{}\nStdout:{}".format(rv.stderr.decode(),rv.stdout.decode()))
    globallock.release()
    
    
def analyze_complete_fasta_folder_with_paup(quartet_path,method = "nj"):
    import time
    t= time.time()
    files = glob.glob(quartet_path+"/*.fasta")
    print(files[0])
    nexus_file_list = []
    for fasta_path in files:
        nexus_file = fasta_path.replace(".fasta",".nex")
        nexus_content,out_path = nexus_from_fasta(fasta_path,method)
        with open(nexus_file,"w") as f:
            f.write(nexus_content)
        nexus_file_list.append(nexus_file)

    
    m = multiprocessing.Manager()
    l = m.Lock()
    args = [(filepath,l) for filepath in nexus_file_list]
    with Pool(16) as p:
        p.map(paup_tree_processfile, args)
    print("running paup on all quartets took: {}".format(time.time()-t))


def analyze_fasta_file_with_paup(fasta_path,method = "nj"):
    """
    This method creates a suitable NEXUS file for a given .fasta file and runs PAUP on the created files. 
    Method is the method that PAUP* is supposed to use (Currently only neighbor joining ("nj") and maximum parsimony ("mp") are supported.)
    """

    nexus_file = fasta_path.replace(".fasta",".nex")
    nexus_content,out_path = nexus_from_fasta(fasta_path,method)

    with open(nexus_file,"w") as f:
        f.write(nexus_content)



    run = subprocess.run(["paup4a166_ubuntu64",nexus_file,"--noninteractive"])
    
    with open(out_path,"r") as f: 
        paup_newick_1 = f.readline();
        
    return paup_newick_1.rstrip()



